# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?

  We initiate instances on the console.rb file in which we create Property.new and enter details onto the hash of options.

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

  In the properties.rb file where we define the 'save' method. This communicates with SQL with require('pg').

Q3. In console.rb, which lines modify the database?

  property1.save and so on - this saves the instances of the Property class into the database.

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

  We do not do this because we want the id to have a serial/automated number that not repeated. We can get this from the database to ensure that there is no duplicate id information within our data. Instead, we pull the serial id from SQL and add it to our hash of options.

Q5. Where and how do we assign the property id (that is generated by the database) to the ruby object?

  We assign the property id within the save method by returning the id.to_i from the database. I'm still getting my head around this part but it somewhat makes sense.

Q6. Why do we put a guard (an ‘if’ clause) on the @id attribute in the constructor?

  We do not want @id to be an option that we pass in if we are initialising in Ruby because we do not yet have this information. Therefore, we only want to use it if there is an existing id for it.

Q7. Why are some of the CRUD actions represented by instance methods, and others, class methods?

  I vaguely understand this... Class methods are when you do not yet have an existing class object to call it on. Instance methods are used when you do have a class object i.e. those initialised in console.rb.

Q8. What type of data structure is returned by db.exec() and db.exec_prepared(), and how do we index into it to pull out a desired attribute?

  Oooft. I think: They return an array which we can index into with (variable[]).

Q9. Why do we use prepared statements when performing database operations?

  Because we don't want anyone being able to mess around and implant nasty SQL commands to access or delete data in our database. We need to protect against SQL injection attacks!

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the Property class.

Q10. What do they take in as their arguments?

  They take in address & id.

Q11. What are their return values?

  They return an array of matching values.
